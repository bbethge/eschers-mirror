#!/usr/bin/env python

import sys
sys.path += ['build/lib.linux-x86_64-2.6'] # HACK
import OpenGL
#OpenGL.ERROR_CHECKING = False
OpenGL.ERROR_ON_COPY = True
from OpenGL.GL import *
import pygame
from pygame.locals import *
import VideoDecode
import os
from bidict import bidict
import numpy as np
from math import *  # math is delicious

windowSize = 640, 480
videoSize = 1, 1
videoOrigin = 0., 0.
videoAspect = 1.
videoTex = 0

class Tile:
	def grabNotify(self):
		"""Notfiy the tile that it has been grabbed"""
		pass
	
	def rotate(self, dir):
		"""
		Rotate the tile to the next valid angle (determined by the
		grid/tile type).  dir == 1 means ccw; dir == -1 means cw.  Has
		no effect if the grid does not allow rotations.
		"""
		pass

class RightTriGrid:
	def __init__(self, rows, cols):
		self.cols = cols
		self.rows = rows
		self.tiles = bidict()
		import itertools
		for loc in itertools.product(range(cols), range(rows), range(2)):
			self.tiles[loc] =  RightTriTile(self, loc)
		self.grabbedTile = None
	
	def draw(self, aspect):
		for tile in self.tiles.itervalues():
			if tile is not self.grabbedTile:
				tile.draw(aspect)
		if self.grabbedTile is not None:
			pos = getMousePos()
			if 0. <= pos[0] < videoAspect and 0. <= pos[1] < 1.:
				loc = self.findTile(pos)
				if self.grabbedIdx == loc[2]:
					self.tiles[loc].drawHighlight(aspect)
			self.grabbedTile.draw(aspect)
	
	def swapTiles(self, loc1, loc2):
		tile1 = self.tiles[loc1]
		self.tiles[loc1] = self.tiles[loc2]
		self.tiles[loc2] = tile1
	
	def grabTile(self, pos):
		"""Grab the tile under the cursor"""
		if self.grabbedTile is None:
			if 0. <= pos[0] < videoAspect and 0. <= pos[1] < 1.:
				loc = self.findTile(pos)
				self.grabbedTile = self.tiles[loc]
				self.grabOffset = (
					(loc[0]+0.5)*videoAspect/self.cols - pos[0],
					(loc[1]+0.5)/self.rows - pos[1])
				self.grabbedIdx = loc[2]
	
	def rotateGrabbed(self, dirxn):
		"""
		Rotate the currently grabbed tile to the next valid angle
		(determined by the grid/tile type).  dirxn == 1 means ccw;
		dirxn == -1 means cw.
		"""
		if self.grabbedTile is not None:
			self.grabbedIdx = (self.grabbedIdx+dirxn) % 2
			self.grabOffset = [ -x for x in self.grabOffset ]
	
	def findTile(self, pos):
		"""
		Find the location (col, row, idx) of the tile at normalized
		coordinates pos
		"""
		col = int(self.cols*pos[0]/videoAspect)
		row = int(self.rows*pos[1])
		cellX = self.cols*pos[0]/videoAspect - col
		cellY = self.rows*pos[1] - row
		if cellX + cellY < 1:
			idx = 0
		else:
			idx = 1
		return col, row, idx
	
	def releaseTile(self, pos):
		if self.grabbedTile is None:
			return
		if 0. <= pos[0] < videoAspect and 0. <= pos[1] < 1.:
			loc = self.findTile(pos)
			if loc[2] == self.grabbedIdx:
				self.swapTiles(
					loc, self.tiles.inv[self.grabbedTile])
			self.grabbedTile = None
	
	def isSolved(self):
		"""
		Does self have all its tiles in the right place?
		"""
		for loc, tile in self.tiles.iteritems():
			if loc != tile.srcLoc:
				return False
		return True
	
	def shuffle(self):
		import random
		locs = self.tiles.keys()
		for i in range(len(locs)-1):
			self.swapTiles(locs[i], random.choice(locs[i+1:]))

class RightTriTile(Tile):
	verts = np.array(
		[	[-0.5, -0.5],
			[ 0.5, -0.5],
			[-0.5,  0.5] ],
		np.double)
	hlWidth = 0.1
	hlTex = 0
	hlSideVerts = np.empty((len(verts)*4,2), np.double)
	hlSideTexCoords = np.empty_like(hlSideVerts)
	rotMat = np.matrix(
		[	[ 0., -1.],
			[ 1.,  0.] ],
		np.double)
	for i in range(len(verts)):
		nextI = (i+1) % len(verts)
		side = verts[nextI] - verts[i]
		side *= hlWidth / np.hypot(*side)
		offset = side*rotMat
		hlSideVerts[4*i] = verts[i]
		hlSideVerts[4*i+1] = verts[i] + offset
		hlSideVerts[4*i+2] = verts[nextI] + offset
		hlSideVerts[4*i+3] = verts[nextI]
		hlSideTexCoords[4*i] = [0.5, 1.]
		hlSideTexCoords[4*i+1] = [1.5, 1.]
		hlSideTexCoords[4*i+2] = [1.5, 1.]
		hlSideTexCoords[4*i+3] = [0.5, 1.]
	hlCornerVerts = []
	hlCornerTexCoords = []
	for i in range(len(verts)):
		nextI = (i+1) % len(verts)
		prevI = (i-1) % len(verts)
		side1 = verts[i] - verts[prevI]
		np.divide(side1, np.hypot(*side1), side1)
		side2 = verts[nextI] - verts[i]
		np.divide(side2, np.hypot(*side2), side2)
		perp1 = np.array(side1 * rotMat, np.double)
		perp2 = np.array(side2 * rotMat, np.double)
		angle = acos(np.sum(perp1*perp2))
		slices = int(ceil(angle/(pi/16)))
		fanVerts = np.empty((slices+2,2), np.double)
		fanVerts[0] = verts[i]
		offset = hlWidth*perp1
		miniRotMat = np.matrix(
			[	[ cos(angle/slices), sin(angle/slices)],
				[-sin(angle/slices), cos(angle/slices)] ],
			np.double)
		for n in range(slices):
			fanVerts[n+1] = verts[i] + offset
			offset = offset * miniRotMat
		fanVerts[slices+1] = verts[i] + hlWidth*perp2
		hlCornerVerts += [fanVerts]
		hlCornerTexCoords += [
			np.array(
				[[0.5, 1.]] + [[1.5, 1.]]*(slices+1),
				np.double)
			]
	
	def __init__(self, grid, srcLoc):
		self.grid = grid
		self.srcLoc = srcLoc
		if RightTriTile.hlTex == 0:
			RightTriTile.hlTex = glGenTextures(1)
			glBindTexture(GL_TEXTURE_2D, RightTriTile.hlTex)
			glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAX_LEVEL, 0)
			texels = np.array(
				[	[ [255, 255, 0, 255], [127, 255, 0,   0] ],
					[ [255, 255, 0, 255], [127, 255, 0,   0] ] ],
				np.uint8)
			glTexImage2Dub(
				GL_TEXTURE_2D, 0, GL_RGBA, 0, GL_RGBA, texels)
	
	def draw(self, aspect):
		"""
		Draw the tile.
		aspect: aspect ratio of the video
		"""
		width = aspect/self.grid.cols
		height = 1.0/self.grid.rows
		srcX = (self.srcLoc[0]+0.5)*width
		srcY = (self.srcLoc[1]+0.5)*height
		if self.grabbed():
			mouseX, mouseY = getMousePos()
			dstX = mouseX + self.grid.grabOffset[0]
			dstY = mouseY + self.grid.grabOffset[1]
			dstIdx = self.grid.grabbedIdx
			glEnable(GL_BLEND)
			glColor4d(0, 0, 0, 0.8)
		else:
			col, row, dstIdx = self.grid.tiles.inv[self]
			dstX = (col+0.5)*width
			dstY = (row+0.5)*height
		glPushMatrix()
		glTranslated(dstX, dstY, 0.)
		glRotated(180*dstIdx, 0, 0, 1)
		glScaled(width, height, 1.)
		glMatrixMode(GL_TEXTURE)
		glPushMatrix()
		glTranslated(srcX, srcY, 0.)
		glRotated(180*self.srcLoc[2], 0, 0, 1)
		glScaled(width, height, 1.)
		
		glBindTexture(GL_TEXTURE_2D, videoTex)
		glTexCoordPointerd(RightTriTile.verts)
		glVertexPointerd(RightTriTile.verts)
		
		glDrawArrays(GL_TRIANGLES, 0, 3)
		
		glPopMatrix()
		glMatrixMode(GL_MODELVIEW)
		glPopMatrix()
		if self == self.grid.grabbedTile:
			glDisable(GL_BLEND)
			glColor4d(0, 0, 0, 1)
	
	def drawHighlight(self, aspect):
		width = aspect/self.grid.cols
		height = 1.0/self.grid.rows
		srcX = (self.srcLoc[0]+0.5)*width
		srcY = (self.srcLoc[1]+0.5)*height
		col, row, dstIdx = self.grid.tiles.inv[self]
		dstX = (col+0.5)*width
		dstY = (row+0.5)*height
		glPushMatrix()
		glTranslated(dstX, dstY, 0.)
		glRotated(180*dstIdx, 0, 0, 1)
		glScaled(width, height, 1.)
		
		glEnable(GL_BLEND)
		glBindTexture(GL_TEXTURE_2D, RightTriTile.hlTex)
		glTexCoordPointerd(RightTriTile.hlSideTexCoords)
		glVertexPointerd(RightTriTile.hlSideVerts)
		glDrawArrays(GL_QUADS, 0, len(RightTriTile.hlSideVerts))
		for i in range(len(RightTriTile.hlCornerVerts)):
			glTexCoordPointerd(RightTriTile.hlCornerTexCoords[i])
			glVertexPointerd(RightTriTile.hlCornerVerts[i])
			glDrawArrays(
				GL_TRIANGLE_FAN, 0,
				len(RightTriTile.hlCornerVerts[i]))
		glDisable(GL_BLEND)
		
		glPopMatrix()
	
	def grabbed(self):
		"""Is self currently grabbed?"""
		return self.grid.grabbedTile == self

def handleSizeChange(width, height, aspect):
	global videoSize, videoAspect, videoOrigin
	if aspect >= float(windowSize[0])/windowSize[1]:
		videoSize = windowSize[0], round(windowSize[0]/aspect)
	else:
		videoSize = round(windowSize[1]*aspect), windowSize[1]
	videoOrigin = [ (w-v)/2 for w, v in zip(windowSize, videoSize) ]
	videoAspect = aspect
	# Find the smallest power-of-2--sized square that can contain the frame
	texSize = 1
	while texSize < max(width, height):
		texSize *= 2
	glBindTexture(GL_TEXTURE_2D, videoTex)
	# Set the active texture to a blank texSize*texSize square (the image
	# will be filled in later).
	texInitializer = '\0' * (3*width*height)
	glTexImage2D(
		GL_TEXTURE_2D, 0, GL_RGB, texSize, texSize, 0,
		GL_RGB, GL_UNSIGNED_BYTE, texInitializer)
	# Set up the texture matrix so that the image occupies a region aspect
	# wide by 1.0 high.
	glMatrixMode(GL_TEXTURE)
	glLoadIdentity()
	glTranslated(0.0, float(height)/texSize, 0.0)
	glScaled(float(width)/texSize/aspect, -float(height)/texSize, 1.0)
	# Set up the projection matrix so that the rectangle occupied by the
	# video is aspect wide by 1.0 high, with the origin in the lower left.
	glMatrixMode(GL_PROJECTION)
	glLoadIdentity()
	glOrtho(
		-float(videoOrigin[0])*aspect/videoSize[0],
		float(windowSize[0]-videoOrigin[0])*aspect/videoSize[0],
		-float(windowSize[1]-videoSize[1]-videoOrigin[1])/videoSize[1],
		float(videoOrigin[1]+videoSize[1])/videoSize[1],
		-1.0, 1.0)
	glMatrixMode(GL_MODELVIEW)

def transformMousePos(x, y):
	return (
		float(x-videoOrigin[0])*videoAspect/videoSize[0],
		float(videoOrigin[1]+videoSize[1]-y-1)/videoSize[1])

def getMousePos():
	return transformMousePos(*pygame.mouse.get_pos())

if __name__ == '__main__':
	pygame.display.init()
	pygame.display.set_mode(windowSize, pygame.OPENGL|pygame.DOUBLEBUF)
	glPixelStorei(GL_UNPACK_ALIGNMENT, 1)
	glEnable(GL_TEXTURE_2D)
	glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE)
	glEnableClientState(GL_TEXTURE_COORD_ARRAY)
	glEnableClientState(GL_VERTEX_ARRAY)
	glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA)
	glClearColor(0.0, 0.0, 0.0, 1.0)
	glMatrixMode(GL_MODELVIEW)
	glLoadIdentity()
	videoTex = glGenTextures(1)
	glBindTexture(GL_TEXTURE_2D, videoTex)
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAX_LEVEL, 0)
	grid = RightTriGrid(2, 3)
	grid.shuffle()
	VideoDecode.init(
		os.path.join(os.path.expanduser('~'), '.xine', 'config'),
		sys.argv[1])
	VideoDecode.start()

	oldWidth = 0
	oldHeight = 0
	done = False
	while not done:
		width, height, aspect, data = VideoDecode.getFrame(50)
		if width != None:
			if oldWidth != width or oldHeight != height or videoAspect != aspect:
				handleSizeChange(width, height, aspect)
				oldWidth = width
				oldHeight = height
			glClear(GL_COLOR_BUFFER_BIT)
			glBindTexture(GL_TEXTURE_2D, videoTex)
			glTexSubImage2D(
				GL_TEXTURE_2D, 0, 0, 0, width, height,
				GL_RGB, GL_UNSIGNED_BYTE, data)
			grid.draw(videoAspect)
			pygame.display.flip()
		while True:
			event = pygame.event.poll()
			if event.type == NOEVENT:
				break
			if event.type == QUIT:
				done = True
				break
			if event.type == MOUSEBUTTONDOWN:
				if event.button == 1: # left?
					grid.grabTile(transformMousePos(*event.pos))
				elif event.button == 2: # right?
					grid.rotateGrabbed(1)
			elif event.type == MOUSEBUTTONUP:
				if event.button == 1:
					grid.releaseTile(transformMousePos(*event.pos))
			elif event.type == KEYDOWN:
				if event.key == K_r:
					grid.rotateGrabbed(1)
	VideoDecode.stop()
	VideoDecode.quit()
