#!/usr/bin/env python

import OpenGL
#OpenGL.ERROR_CHECKING = False
OpenGL.ERROR_ON_COPY = True
from OpenGL.GL import *
import pygame
from pygame.locals import *
import cairo
import pango
import pangocairo
import os
from bidict import bidict
import numpy as np
from math import *  # math is delicious
import random
import weakref
import sys
from glob import glob
sys.path += glob(os.path.join('build', '*', ''))
import VideoDecode

winSize = 640, 480

class Signal:
	"""
	A Signal object maintains a list of callbacks which are added and
	removed by parts of the code which are interested in the corresponding
	event.  When the Signal's owner calls the emit method, all the currently
	registered callbacks are called.
	"""
	def __init__(self):
		self.callbacks = set()
		self.methodCallbacks = weakref.WeakValueDictionary()
	
	def addHandler(self, handler, obj=None):
		"""
		Add a signal handler.
		handler: a function or an unbound method
		obj: if handler is an unbound method, this is the object to call
		     the method on
		Passing a bound method (with obj==None) should work, but will
		keep the object that the method is bound to alive until the
		handler is explicitly removed.  Passing the object and the
		method separately allows the handler to be automatically removed
		when the object is no longer needed.
		"""
		if obj == None:
			self.callbacks.add(handler)
		else:
			self.methodCallbacks[handler,weakref.ref(obj)] = obj
	
	def removeHandler(self, handler, obj=None):
		if obj == None:
			self.callbacks.remove(handler)
		else:
			del self.methodCallbacks[handler,weakref.ref(obj)]
	
	def emit(self, *args, **kwargs):
		for cb in self.callbacks:
			cb(*args, **kwargs)
		for cb, objRef in self.methodCallbacks.keys():
			cb(objRef(), *args, **kwargs)

class Grid:
	"""
	The base class for all grid types, which manage the state of a puzzle.
	
	Data members:
	vidSize: the pixel size of the video as it appears on-screen
	vidOrigin: the window coordinates of the origin (lower left) of where
		the video will be drawn
	vidAspect: the aspect ratio the video should be displayed at
	srcVidSize: the pixel size of the source video, which is stored in a
		texture
	vidTex: the texture object holding the current video frame
	"""
	def __init__(self):
		self.vidTex = glGenTextures(1)
		glBindTexture(GL_TEXTURE_2D, self.vidTex)
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAX_LEVEL, 0)
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE)
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE)
		VideoDecode.init(
			os.path.join(os.path.expanduser('~'), '.xine', 'config'),
			sys.argv[1])
		self.vidSize = 1, 1
		self.vidAspect = 1.
		self.srcVidSize = 1, 1
	
	def run(self):
		"""
		Run the main event loop for the puzzle.  This will not return
		until the puzzle is finished -- either won, lost, or aborted.
		"""
		VideoDecode.start()
		done = False
		while not done:
			width, height, aspect, data = VideoDecode.getFrame(50)
			if width != None:
				self.handleFrame((width,height), aspect, data)
			while True:
				event = pygame.event.poll()
				if event.type == NOEVENT:
					break
				if event.type == QUIT:
					done = True
					break
				self.handleEvent(event)
			glClear(GL_COLOR_BUFFER_BIT)
			# What happens if there is no current texture image
			# attached to self.vidTex because we haven't received
			# a frame yet?
			self.draw()
			pygame.display.flip()
		VideoDecode.stop()
		VideoDecode.quit()
	
	def handleFrame(self, size, aspect, data):
		if self.vidSize != size or self.vidAspect != aspect:
			self.handleSizeChange(size[0], size[1], aspect)
		glBindTexture(GL_TEXTURE_2D, self.vidTex)
		glTexSubImage2D(
			GL_TEXTURE_2D, 0, 0, 0, size[0], size[1],
			GL_RGB, GL_UNSIGNED_BYTE, data)
	
	def handleEvent(self, event):
		if event.type == MOUSEBUTTONDOWN:
			if event.button == 1: # left?
				self.grabTile(self.transformMousePos(*event.pos))
			elif event.button == 2: # right?
				self.rotateGrabbed(1)
		elif event.type == MOUSEBUTTONUP:
			if event.button == 1:
				self.releaseTile(self.transformMousePos(*event.pos))
		elif event.type == KEYDOWN:
			if event.key == K_r:
				self.rotateGrabbed(1)
	
	def handleSizeChange(self, width, height, aspect):
		if aspect >= float(winSize[0])/winSize[1]:
			self.vidSize = winSize[0], round(winSize[0]/aspect)
		else:
			self.vidSize = round(winSize[1]*aspect), winSize[1]
		self.vidOrigin = [
			(w-v)/2 for w, v in zip(winSize, self.vidSize) ]
		self.vidAspect = aspect
		self.srcVidSize = width, height
		# Find the smallest power-of-2--sized square that can contain
		# the frame
		texSize = 1
		while texSize < max(width, height):
			texSize *= 2
		glBindTexture(GL_TEXTURE_2D, self.vidTex)
		# Set the active texture to a blank texSize*texSize square (the
		# image will be filled in later).
		texInitializer = np.zeros((texSize,texSize,3), np.uint8)
		glTexImage2Dub(
			GL_TEXTURE_2D, 0, GL_RGB, 0, GL_RGB, texInitializer)
		# Set up the texture matrix to compensate for the pixel data
		# being in top-to-bottom order.
		glMatrixMode(GL_TEXTURE)
		glLoadIdentity()
		glScaled(1./texSize, -1./texSize, 1.)
		glTranslated(0., -float(height), 0.)
		# Set up the projection matrix so that the origin is at the
		# lower left corner of the video.
		glMatrixMode(GL_PROJECTION)
		glLoadIdentity()
		glOrtho(
			-self.vidOrigin[0], winSize[0]-self.vidOrigin[0],
			-self.vidOrigin[1], winSize[1]-self.vidOrigin[1],
			-1.0, 1.0)
		glMatrixMode(GL_MODELVIEW)
	
	def draw(self):
		pass
	
	def grabTile(self, pos):
		"""
		Grab the tile under the cursor
		"""
		pass
	
	def releaseTile(self, pos):
		pass
	
	def rotateGrabbed(self, dirxn):
		"""
		Rotate the currently grabbed tile to the next valid angle
		(determined by the grid/tile type).  dirxn == 1 means ccw;
		dirxn == -1 means cw.
		"""
		pass
	
	def isSolved(self):
		"""
		Does self have all its tiles in the right place?
		"""
		pass
	
	def shuffle(self):
		pass

	def transformMousePos(self, x, y):
		return x-self.vidOrigin[0], winSize[1]-self.vidOrigin[1]-y
	
	def getMousePos(self):
		return self.transformMousePos(*pygame.mouse.get_pos())

class RightTriGrid(Grid):
	def __init__(self, rows, cols):
		Grid.__init__(self)
		self.cols = cols
		self.rows = rows
		self.tiles = bidict()
		self.timeDisplay = None
		import itertools
		for loc in itertools.product(range(cols), range(rows), range(2)):
			self.tiles[loc] =  RightTriTile(self, loc)
		self.grabbedTile = None
		self.shuffle()
	
	def draw(self):
		for tile in self.tiles.itervalues():
			if tile is not self.grabbedTile:
				tile.draw(self.vidAspect)
		if self.grabbedTile is not None:
			pos = self.getMousePos()
			if 0. <= pos[0] < self.vidSize[0] and 0. <= pos[1] < self.vidSize[1]:
				loc = self.findTile(pos)
				if self.grabbedIdx == loc[2]:
					self.tiles[loc].drawHighlight(self.vidAspect)
			self.grabbedTile.draw(self.vidAspect)
		if self.timeDisplay is not None:
			self.timeDisplay.draw()
	
	def swapTiles(self, loc1, loc2):
		tile1 = self.tiles[loc1]
		self.tiles[loc1] = self.tiles[loc2]
		self.tiles[loc2] = tile1
	
	def grabTile(self, pos):
		if self.grabbedTile is None:
			if 0. <= pos[0] < self.vidSize[0] and 0. <= pos[1] < self.vidSize[1]:
				loc = self.findTile(pos)
				self.grabbedTile = self.tiles[loc]
				self.grabOffset = (
					(loc[0]+0.5)*self.vidSize[0]/self.cols - pos[0],
					(loc[1]+0.5)*self.vidSize[1]/self.rows - pos[1])
				self.grabbedIdx = loc[2]
	
	def rotateGrabbed(self, dirxn):
		if self.grabbedTile is not None:
			self.grabbedIdx = (self.grabbedIdx+dirxn) % 2
			self.grabOffset = [ -x for x in self.grabOffset ]
	
	def findTile(self, pos):
		"""
		Find the location (col, row, idx) of the tile at video
		coordinates pos
		"""
		col = int(self.cols*pos[0]/self.vidSize[0])
		row = int(self.rows*pos[1]/self.vidSize[1])
		cellX = float(self.cols*pos[0])/self.vidSize[0] - col
		cellY = float(self.rows*pos[1])/self.vidSize[1] - row
		if cellX + cellY < 1.:
			idx = 0
		else:
			idx = 1
		return col, row, idx
	
	def releaseTile(self, pos):
		if self.grabbedTile is None:
			return
		if 0. <= pos[0] < self.vidSize[0] and 0. <= pos[1] < self.vidSize[1]:
			loc = self.findTile(pos)
			if loc[2] == self.grabbedIdx:
				self.swapTiles(
					loc, self.tiles.inv[self.grabbedTile])
			self.grabbedTile = None
			if self.isSolved():
				self.timeDisplay = \
					TimeDisplay(self, VideoDecode.getPosition())
	
	def isSolved(self):
		for loc, tile in self.tiles.iteritems():
			if loc != tile.srcLoc:
				return False
		return True
	
	def shuffle(self):
		locs = self.tiles.keys()
		for i in range(len(locs)-1):
			self.swapTiles(locs[i], random.choice(locs[i+1:]))

class RightTriTile:
	verts = np.array(
		[	[-0.5, -0.5],
			[ 0.5, -0.5],
			[-0.5,  0.5] ],
		np.double)
	hlWidth = 0.1
	hlTex = 0
	hlSideVerts = np.empty((len(verts)*4,2), np.double)
	hlSideTexCoords = np.empty_like(hlSideVerts)
	rotMat = np.matrix(
		[	[ 0., -1.],
			[ 1.,  0.] ],
		np.double)
	for i in range(len(verts)):
		nextI = (i+1) % len(verts)
		side = verts[nextI] - verts[i]
		side *= hlWidth / np.hypot(*side)
		offset = side*rotMat
		hlSideVerts[4*i] = verts[i]
		hlSideVerts[4*i+1] = verts[i] + offset
		hlSideVerts[4*i+2] = verts[nextI] + offset
		hlSideVerts[4*i+3] = verts[nextI]
		hlSideTexCoords[4*i] = [0., 0.5]
		hlSideTexCoords[4*i+1] = [1., 0.5]
		hlSideTexCoords[4*i+2] = [1., 0.5]
		hlSideTexCoords[4*i+3] = [0., 0.5]
	hlCornerVerts = []
	hlCornerTexCoords = []
	for i in range(len(verts)):
		nextI = (i+1) % len(verts)
		prevI = (i-1) % len(verts)
		side1 = verts[i] - verts[prevI]
		np.divide(side1, np.hypot(*side1), side1)
		side2 = verts[nextI] - verts[i]
		np.divide(side2, np.hypot(*side2), side2)
		perp1 = np.array(side1 * rotMat, np.double)
		perp2 = np.array(side2 * rotMat, np.double)
		angle = acos(np.sum(perp1*perp2))
		slices = int(ceil(angle/(pi/16)))
		fanVerts = np.empty((slices+2,2), np.double)
		fanVerts[0] = verts[i]
		offset = hlWidth*perp1
		miniRotMat = np.matrix(
			[	[ cos(angle/slices), sin(angle/slices)],
				[-sin(angle/slices), cos(angle/slices)] ],
			np.double)
		for n in range(slices):
			fanVerts[n+1] = verts[i] + offset
			offset = offset * miniRotMat
		fanVerts[slices+1] = verts[i] + hlWidth*perp2
		hlCornerVerts += [fanVerts]
		hlCornerTexCoords += [
			np.array(
				[[0., 0.5]] + [[1., 0.5]]*(slices+1),
				np.double)
			]
	
	def __init__(self, grid, srcLoc):
		self.grid = grid
		self.srcLoc = srcLoc
		if RightTriTile.hlTex == 0:
			RightTriTile.hlTex = glGenTextures(1)
			glBindTexture(GL_TEXTURE_2D, RightTriTile.hlTex)
			glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAX_LEVEL, 0)
			texels = np.array(
				[	[ [255, 255, 0, 255], [127, 255, 0, 0] ],
					[ [255, 255, 0, 255], [127, 255, 0, 0] ] ],
				np.uint8)
			glTexImage2Dub(
				GL_TEXTURE_2D, 0, GL_RGBA, 0, GL_RGBA, texels)
	
	def draw(self, aspect):
		"""
		Draw the tile.
		aspect: aspect ratio of the video
		"""
		width = float(self.grid.vidSize[0])/self.grid.cols
		height = float(self.grid.vidSize[1])/self.grid.rows
		srcWidth = float(self.grid.srcVidSize[0])/self.grid.cols
		srcHeight = float(self.grid.srcVidSize[1])/self.grid.rows
		srcX = (self.srcLoc[0]+0.5)*srcWidth
		srcY = (self.srcLoc[1]+0.5)*srcHeight
		if self.grabbed():
			mouseX, mouseY = grid.getMousePos()
			dstX = mouseX + self.grid.grabOffset[0]
			dstY = mouseY + self.grid.grabOffset[1]
			dstIdx = self.grid.grabbedIdx
			glEnable(GL_BLEND)
			glColor4d(0, 0, 0, 0.8)
		else:
			col, row, dstIdx = self.grid.tiles.inv[self]
			dstX = (col+0.5)*width
			dstY = (row+0.5)*height
		glPushMatrix()
		glTranslated(dstX, dstY, 0.)
		glRotated(180*dstIdx, 0, 0, 1)
		glScaled(width, height, 1.)
		glMatrixMode(GL_TEXTURE)
		glPushMatrix()
		glTranslated(srcX, srcY, 0.)
		glRotated(180*self.srcLoc[2], 0, 0, 1)
		glScaled(srcWidth, srcHeight, 1.)
		
		glBindTexture(GL_TEXTURE_2D, self.grid.vidTex)
		glTexCoordPointerd(RightTriTile.verts)
		glVertexPointerd(RightTriTile.verts)
		
		glDrawArrays(GL_TRIANGLES, 0, 3)
		
		glPopMatrix()
		glMatrixMode(GL_MODELVIEW)
		glPopMatrix()
		if self == self.grid.grabbedTile:
			glDisable(GL_BLEND)
			glColor4d(0, 0, 0, 1)
	
	def drawHighlight(self, aspect):
		width = float(self.grid.vidSize[0])/self.grid.cols
		height = float(self.grid.vidSize[1])/self.grid.rows
		col, row, dstIdx = self.grid.tiles.inv[self]
		dstX = (col+0.5)*width
		dstY = (row+0.5)*height
		glPushMatrix()
		glTranslated(dstX, dstY, 0.)
		glRotated(180*dstIdx, 0, 0, 1)
		glScaled(width, height, 1.)
		glMatrixMode(GL_TEXTURE)
		glPushMatrix()
		glLoadIdentity()
		glScaled(0.5, 1., 1.)
		glTranslated(0.5, 0., 0.)
		
		glEnable(GL_BLEND)
		glBindTexture(GL_TEXTURE_2D, RightTriTile.hlTex)
		glTexCoordPointerd(RightTriTile.hlSideTexCoords)
		glVertexPointerd(RightTriTile.hlSideVerts)
		glDrawArrays(GL_QUADS, 0, len(RightTriTile.hlSideVerts))
		for i in range(len(RightTriTile.hlCornerVerts)):
			glTexCoordPointerd(RightTriTile.hlCornerTexCoords[i])
			glVertexPointerd(RightTriTile.hlCornerVerts[i])
			glDrawArrays(
				GL_TRIANGLE_FAN, 0,
				len(RightTriTile.hlCornerVerts[i]))
		glDisable(GL_BLEND)
		
		glPopMatrix()
		glMatrixMode(GL_MODELVIEW)
		glPopMatrix()
	
	def grabbed(self):
		"""Is self currently grabbed?"""
		return self.grid.grabbedTile == self

class TimeDisplay:
	def __init__(self, grid, time):
		self.grid = grid
		timeStr = "%d:%02d" % (int(time/60), int(time%60))
		surface = cairo.ImageSurface(
			cairo.FORMAT_A8, winSize[0], winSize[1])
		cairoCtx = cairo.Context(surface)
		pangoCtx = pangocairo.CairoContext(cairoCtx)
		layout = pangoCtx.create_layout()
		layout.set_markup("""\
<span foreground="yellow"><span size="large">Congratulations!</span>
Your time is
<span size="72000">%s</span></span>""" % timeStr)
		layout.set_alignment(pango.ALIGN_CENTER)
		pangoCtx.show_layout(layout)
		self.size = layout.get_pixel_size()
		arrData = np.frombuffer(surface.get_data(), np.uint8)
		arrData = arrData.reshape((winSize[1],winSize[0]))
		color = np.array([255, 255, 0, 255], np.uint8)
		self.pixelData = np.tile(color, (self.size[1], self.size[0], 1))
		self.pixelData[:,:,3] = arrData[:self.size[1], :self.size[0]]
		del surface
	
	def draw(self):
		glDisable(GL_TEXTURE_2D)
		glEnable(GL_BLEND)
		glColor4d(0., 0., 0., 0.5)
		glRectd(
			(self.grid.vidSize[0]-self.size[0])/2.,
			(self.grid.vidSize[1]-self.size[1])/2.,
			(self.grid.vidSize[0]+self.size[0])/2.,
			(self.grid.vidSize[1]+self.size[1])/2.)
		glRasterPos2d(
                        (self.grid.vidSize[0]-self.size[0])/2.,
                        (self.grid.vidSize[1]+self.size[1])/2.)
		oldZoomX = glGetDouble(GL_ZOOM_X)
		oldZoomY = glGetDouble(GL_ZOOM_Y)
		glPixelZoom(1., -1.)
		glDrawPixels(
			self.size[0], self.size[1], GL_RGBA, GL_UNSIGNED_BYTE,
			self.pixelData)
		glPixelZoom(oldZoomX, oldZoomY)
		glDisable(GL_BLEND)
		glEnable(GL_TEXTURE_2D)

if __name__ == '__main__':
	pygame.display.init()
	pygame.font.init()
	pygame.display.set_mode(winSize, pygame.OPENGL|pygame.DOUBLEBUF)
	pygame.display.set_caption("Escher's Mirror", "Escher's Mirror")
	glPixelStorei(GL_UNPACK_ALIGNMENT, 1)
	glEnable(GL_TEXTURE_2D)
	glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE)
	glEnableClientState(GL_TEXTURE_COORD_ARRAY)
	glEnableClientState(GL_VERTEX_ARRAY)
	glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA)
	glClearColor(0.0, 0.0, 0.0, 1.0)
	glMatrixMode(GL_MODELVIEW)
	glLoadIdentity()
	
	grid = RightTriGrid(2, 3)
	grid.run()
