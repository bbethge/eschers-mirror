#!/usr/bin/env python

import OpenGL
#OpenGL.ERROR_CHECKING = False
OpenGL.ERROR_ON_COPY = True
from OpenGL.GL import *
import pygame
from pygame.locals import *
import cairo
import pango
import pangocairo
import os
import numpy as np
from math import *  # math is delicious
import random
import weakref
import sys
from glob import glob
sys.path += glob(os.path.join('build', '*', ''))
import VideoDecode
import time

winSize = 640, 480

class Signal:
	"""
	A Signal object maintains a list of callbacks which are added and removed by 
	parts of the code which are interested in the corresponding event.  When the
	Signal's owner calls the emit method, all the currently registered callbacks 
	are called.
	"""
	def __init__(self):
		self.callbacks = set()
		self.methodCallbacks = weakref.WeakValueDictionary()
	
	def addHandler(self, handler, obj=None):
		"""
		Add a signal handler.
		handler: a function or an unbound method
		obj: if handler is an unbound method, this is the object to call the
		     method on
		Passing a bound method (with obj==None) should work, but will keep the 
		object that the method is bound to alive until the handler is explicitly 
		removed.  Passing the object and the method separately allows the
		handler to be automatically removed when the object is no longer needed.
		"""
		if obj == None:
			self.callbacks.add(handler)
		else:
			self.methodCallbacks[handler,weakref.ref(obj)] = obj
	
	def removeHandler(self, handler, obj=None):
		if obj == None:
			self.callbacks.remove(handler)
		else:
			del self.methodCallbacks[handler,weakref.ref(obj)]
	
	def emit(self, *args, **kwargs):
		for cb in self.callbacks:
			cb(*args, **kwargs)
		for cb, objRef in self.methodCallbacks.keys():
			cb(objRef(), *args, **kwargs)

class Actor:
	"""
	A class for objects that behave on their own
	"""
	def __init__(self, grid):
		"""
		grid: the grid (puzzle) object that manages this object
		"""
		self.grid = grid
		grid.add(self)
	
	def update(self, deltaT):
		"""
		This is called by the grid before every frame so the object can update
		its state.
		deltaT: time in seconds since last update; zero if this is the first
		        update
		"""
		pass
	
	def die(self):
		self.grid.remove(self)

class Grid:
	"""
	The base class for all grid types, which manage the state of a puzzle.
	
	Data members:
	vidSize: the pixel size of the video as it appears on-screen
	vidOrigin: the window coordinates of the origin (lower left) of where the 
	           video will be drawn
	vidAspect: the aspect ratio the video should be displayed at
	srcVidSize: the pixel size of the source video, which is stored in a texture
	vidTex: the texture object holding the current video frame
	"""
	def __init__(self):
		# Set up vidTex
		self.vidTex = glGenTextures(1)
		glBindTexture(GL_TEXTURE_2D, self.vidTex)
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAX_LEVEL, 0)
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE)
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE)
		
		VideoDecode.init(
			os.path.join(os.path.expanduser('~'), '.xine', 'config'),
			sys.argv[1])
		self.vidSize = 1, 1
		self.vidAspect = 1.
		self.srcVidSize = 1, 1
		self.actors = set()
		self.drawFixedTiles = Signal()
		self.drawFlyingTiles = Signal()
		self.drawOverlays = Signal()
		self.startGrab = Signal()
		self.endGrab = Signal()
		self.rotateTile = Signal()
	
	def add(self, actor):
		self.actors.add(actor)
	
	def remove(self, actor):
		self.actors.remove(actor)
	
	def run(self):
		"""
		Run the main event loop for the puzzle.  This will not return until the 
		puzzle is finished -- either won, lost, or aborted.
		"""
		VideoDecode.start()
		oldTime = time.time()
		done = False
		while not done and VideoDecode.isPlaying():
			width, height, aspect, data = VideoDecode.getFrame(20)
			if width != None:
				self.handleFrame((width,height), aspect, data)
			while True:
				event = pygame.event.poll()
				if event.type == NOEVENT:
					break
				if event.type == QUIT:
					done = True
					break
				self.handleEvent(event)
			curTime = time.time()
			deltaT = curTime - oldTime
			oldTime = curTime
			# Actors may remove themselves during the update, so we must iterate 
			# over a copy of self.actors.  FIXME: what if actors remove other
			# actors?
			for actor in set(self.actors):
				actor.update(deltaT)
			glClear(GL_COLOR_BUFFER_BIT)
			# What happens if there is no current texture image attached to
			# self.vidTex because we haven't received a frame yet?
			self.draw()
			self.drawOverlays.emit()
			pygame.display.flip()
		VideoDecode.stop()
		VideoDecode.quit()
	
	def handleFrame(self, size, aspect, data):
		if self.vidSize != size or self.vidAspect != aspect:
			self.handleSizeChange(size[0], size[1], aspect)
		glBindTexture(GL_TEXTURE_2D, self.vidTex)
		glTexSubImage2D(
			GL_TEXTURE_2D, 0, 0, 0, size[0], size[1],
			GL_RGB, GL_UNSIGNED_BYTE, data)
	
	def handleEvent(self, event):
		if event.type == MOUSEBUTTONDOWN:
			if event.button == 1: # left?
				self.grabTile(self.transformMousePos(*event.pos))
			elif event.button == 3: # right?
				self.rotateTile.emit(1)
		elif event.type == MOUSEBUTTONUP:
			if event.button == 1:
				self.releaseTile(self.transformMousePos(*event.pos))
		elif event.type == KEYDOWN:
			if event.key == K_r:
				if event.mod & KMOD_SHIFT:
					self.rotateTile.emit(-1)
				else:
					self.rotateTile.emit(1)
	
	def handleSizeChange(self, width, height, aspect):
		if aspect >= float(winSize[0])/winSize[1]:
			self.vidSize = winSize[0], round(winSize[0]/aspect)
		else:
			self.vidSize = round(winSize[1]*aspect), winSize[1]
		self.vidOrigin = [ (w-v)/2 for w, v in zip(winSize, self.vidSize) ]
		self.vidAspect = aspect
		self.srcVidSize = width, height
		# Find the smallest power-of-2--sized square that can contain the frame
		texSize = 1
		while texSize < max(width, height):
			texSize *= 2
		glBindTexture(GL_TEXTURE_2D, self.vidTex)
		# Set the active texture to a blank texSize*texSize square (the image 
		# will be filled in later).
		texInitializer = np.zeros((texSize,texSize,3), np.uint8)
		glTexImage2Dub(GL_TEXTURE_2D, 0, GL_RGB, 0, GL_RGB, texInitializer)
		# Set up the texture matrix to compensate for the pixel data being in
		# top-to-bottom order.
		glMatrixMode(GL_TEXTURE)
		glLoadIdentity()
		glScaled(1./texSize, -1./texSize, 1.)
		glTranslated(0., -float(height), 0.)
		# Set up the projection matrix so that the origin is at the lower left
		# corner of the video.
		glMatrixMode(GL_PROJECTION)
		glLoadIdentity()
		glOrtho(
			-self.vidOrigin[0], winSize[0]-self.vidOrigin[0],
			-self.vidOrigin[1], winSize[1]-self.vidOrigin[1],
			-1.0, 1.0)
		glMatrixMode(GL_MODELVIEW)
	
	def draw(self):
		pass
	
	def grabTile(self, pos):
		"""
		Grab the tile under the cursor
		"""
		self.startGrab.emit(pos)
	
	def releaseTile(self, pos):
		"""
		Release the currently grabbed tile
		"""
		self.endGrab.emit(pos)
		if self.isSolved():
			TimeDisplay(self, VideoDecode.getPosition())
	
	def isSolved(self):
		"""
		Does self have all its tiles in the right place?
		"""
		pass
	
	def shuffle(self):
		"""
		Randomize the locations of the tiles
		"""
		pass

	def transformMousePos(self, x, y):
		"""
		Transform window coordinates into coordinates relative to the video
		origin
		"""
		return x - self.vidOrigin[0], winSize[1] - self.vidOrigin[1] - y
	
	def getMousePos(self):
		"""
		Return the current mouse pointer location relative to the video origin
		"""
		return self.transformMousePos(*pygame.mouse.get_pos())

class RightTriGrid(Grid):
	def __init__(self, rows, cols):
		Grid.__init__(self)
		self.cols = cols
		self.rows = rows
		self.tiles = set()
		import itertools
		for loc in itertools.product(range(cols), range(rows), range(2)):
			self.tiles.add(RightTriTile(self, loc))
		self.grabbedTile = None
		self.shuffle()
	
	def draw(self):
		self.drawFixedTiles.emit(self.vidAspect)
		self.drawFlyingTiles.emit(self.vidAspect)
	
	def findTile(self, pos):
		"""
		Find the location (col, row, idx) of the tile at video coordinates pos
		"""
		col = int(self.cols*pos[0]/self.vidSize[0])
		row = int(self.rows*pos[1]/self.vidSize[1])
		cellX = float(self.cols*pos[0])/self.vidSize[0] - col
		cellY = float(self.rows*pos[1])/self.vidSize[1] - row
		if cellX + cellY < 1.:
			idx = 0
		else:
			idx = 1
		return col, row, idx
	
	def isSolved(self):
		for tile in self.tiles:
			if tile.srcLoc != tile.loc:
				return False
		return True
	
	def shuffle(self):
		unshuf = list(self.tiles)
		while len(unshuf) > 1:
			tile = unshuf.pop()
			otherTile = random.choice(unshuf)
			tile.loc, otherTile.loc = otherTile.loc, tile.loc

class RightTriTile(Actor):
	verts = np.array(
		[	[-0.5, -0.5],
			[ 0.5, -0.5],
			[-0.5,  0.5] ],
		np.double)
	motionBlurSteps = 10
	hlWidth = 0.1
	hlTex = 0
	hlSideVerts = np.empty((len(verts)*4,2), np.double)
	hlSideTexCoords = np.empty_like(hlSideVerts)
	rotMat = np.matrix(  # a matrix for rotating 90 deg ccw
		[	[ 0., -1.],
			[ 1.,  0.] ],
		np.double)
	for i in range(len(verts)):
		nextI = (i+1) % len(verts)
		side = verts[nextI] - verts[i]
		side *= hlWidth / np.hypot(*side)
		offset = side*rotMat
		hlSideVerts[4*i] = verts[i]
		hlSideVerts[4*i+1] = verts[i] + offset
		hlSideVerts[4*i+2] = verts[nextI] + offset
		hlSideVerts[4*i+3] = verts[nextI]
		hlSideTexCoords[4*i] = [0., 0.5]
		hlSideTexCoords[4*i+1] = [1., 0.5]
		hlSideTexCoords[4*i+2] = [1., 0.5]
		hlSideTexCoords[4*i+3] = [0., 0.5]
	hlCornerVerts = []
	hlCornerTexCoords = []
	for i in range(len(verts)):
		nextI = (i+1) % len(verts)
		prevI = (i-1) % len(verts)
		side1 = verts[i] - verts[prevI]
		np.divide(side1, np.hypot(*side1), side1)
		side2 = verts[nextI] - verts[i]
		np.divide(side2, np.hypot(*side2), side2)
		perp1 = np.array(side1 * rotMat, np.double)
		perp2 = np.array(side2 * rotMat, np.double)
		angle = acos(np.sum(perp1*perp2))
		slices = int(ceil(angle/(pi/16)))
		fanVerts = np.empty((slices+2,2), np.double)
		fanVerts[0] = verts[i]
		offset = hlWidth*perp1
		miniRotMat = np.matrix(
			[	[ cos(angle/slices), sin(angle/slices)],
				[-sin(angle/slices), cos(angle/slices)] ],
			np.double)
		for n in range(slices):
			fanVerts[n+1] = verts[i] + offset
			offset = offset * miniRotMat
		fanVerts[slices+1] = verts[i] + hlWidth*perp2
		hlCornerVerts += [fanVerts]
		hlCornerTexCoords += [
			np.array(
				[[0., 0.5]] + [[1., 0.5]]*(slices+1),
				np.double)
			]
	totFlightTime = 0.1
	
	class Pose:
		def __init__(self, *args):
			if len(args) == 1:
				self.pos = np.array(args[0].pos)
				self.angle = args[0].angle
			else:
				self.pos = np.array(args[0])
				self.angle = args[1]
	
	def __init__(self, grid, loc):
		Actor.__init__(self, grid)
		self.srcLoc = loc
		self.loc = loc
		if RightTriTile.hlTex == 0:
			RightTriTile.hlTex = glGenTextures(1)
			glBindTexture(GL_TEXTURE_2D, RightTriTile.hlTex)
			glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAX_LEVEL, 0)
			texels = np.array(
				[	[ [255, 255, 0, 255], [127, 255, 0, 0] ],
					[ [255, 255, 0, 255], [127, 255, 0, 0] ] ],
				np.uint8)
			glTexImage2Dub(GL_TEXTURE_2D, 0, GL_RGBA, 0, GL_RGBA, texels)
		self.grid.drawFixedTiles.addHandler(self.__class__.draw, self)
		self.grid.startGrab.addHandler(self.__class__.startGrab, self)
		self.state = 'sitting'
	
	def update(self, deltaT):
		if self.state == 'flying':
			self.flightTime += deltaT
			self.pose = self.Pose(self.nextPose)
			if self.flightTime < self.totFlightTime:
				self.nextPose.pos += self.flyingVel.pos * deltaT
				self.nextPose.angle += self.flyingVel.angle * deltaT
			else:
				self.endFlying()
	
	def startGrab(self, mousePos):
		localX = (
			float(mousePos[0])*self.grid.cols/self.grid.vidSize[0]-self.loc[0])
		localY = (
			float(mousePos[1])*self.grid.rows/self.grid.vidSize[1]-self.loc[1])
		if (
				0. <= localX < 1. and 0. <= localY < 1.
				and (localX+localY < 1.) == (self.loc[2] == 0)
		):
			self.state = 'grabbed'
			pose = self.locToPose(self.loc)
			self.mouseOffset = pose.pos - mousePos
			self.grabbedIdx = self.loc[2]
			self.grid.endGrab.addHandler(self.__class__.endGrab, self)
			self.grid.rotateTile.addHandler(self.__class__.rotate, self)
			self.grid.drawFixedTiles.removeHandler(self.__class__.draw, self)
			self.grid.drawFlyingTiles.addHandler(self.__class__.draw, self)
	
	def endGrab(self, mousePos):
		self.state = 'flying'
		self.grid.rotateTile.removeHandler(self.__class__.rotate, self)
		self.grid.endGrab.removeHandler(self.__class__.endGrab, self)
		targetLoc = self.grid.findTile(mousePos)
		if targetLoc[2] == self.grabbedIdx:
			for tile in self.grid.tiles:
				if tile.loc == targetLoc:
					self.swapWith(tile)
					break
			else:
				raise RuntimeError("Couln't find tile at "+str(targetLoc))
		curPos = self.mouseOffset + mousePos
		self.startFlying(
			self.Pose(curPos, 180*self.grabbedIdx), self.locToPose(self.loc))
		del self.grabbedIdx
		del self.mouseOffset
	
	def rotate(self, dirxn):
		self.grabbedIdx = (self.grabbedIdx+dirxn) % 2
		self.mouseOffset = -self.mouseOffset
	
	def swapWith(self, other):
		loc = self.loc
		#self.__setLoc(other.loc)
		self.loc = other.loc
		other.__setLoc(loc)
	
	def __setLoc(self, loc):
		self.startFlying(self.locToPose(self.loc), self.locToPose(loc))
		self.loc = loc
	
	def startFlying(self, startPose, endPose):
		self.pose = self.Pose(np.empty(2), 0)  # This value shouldn't actually be used
		self.nextPose = self.Pose(startPose)
		# Awkwardly, flyingVel is a Pose object even though it is more like the
		# time derivative of a pose.
		self.flyingVel = self.Pose(
			(endPose.pos-self.nextPose.pos) / self.totFlightTime,
			(endPose.angle-self.nextPose.angle) / self.totFlightTime)
		self.flightTime = 0.
		if self.state == 'sitting':
			self.grid.drawFixedTiles.removeHandler(self.__class__.draw, self)
			self.grid.drawFlyingTiles.addHandler(self.__class__.draw, self)
		self.state = 'flying'
	
	def endFlying(self):
		self.state = 'sitting'
		self.grid.drawFlyingTiles.removeHandler(self.__class__.draw, self)
		self.grid.drawFixedTiles.addHandler(self.__class__.draw, self)
		del self.flightTime
		del self.flyingVel
		del self.nextPose
		del self.pose
	
	def locToPose(self, loc):
		return self.Pose(
			np.array(
				[ (loc[0]+0.5) * self.grid.vidSize[0] / self.grid.cols,
				  (loc[1]+0.5) * self.grid.vidSize[1] / self.grid.rows ],
				np.double),
			loc[2] * 180)
	
	def draw(self, aspect):
		"""
		Draw the tile.
		aspect: aspect ratio of the video
		"""
		width = float(self.grid.vidSize[0])/self.grid.cols
		height = float(self.grid.vidSize[1])/self.grid.rows
		srcWidth = float(self.grid.srcVidSize[0])/self.grid.cols
		srcHeight = float(self.grid.srcVidSize[1])/self.grid.rows
		srcX = (self.srcLoc[0]+0.5)*srcWidth
		srcY = (self.srcLoc[1]+0.5)*srcHeight
		glMatrixMode(GL_TEXTURE)
		glPushMatrix()
		glTranslated(srcX, srcY, 0.)
		glRotated(180*self.srcLoc[2], 0, 0, 1)
		glScaled(srcWidth, srcHeight, 1.)
		glMatrixMode(GL_MODELVIEW)
		glBindTexture(GL_TEXTURE_2D, self.grid.vidTex)
		glTexCoordPointerd(RightTriTile.verts)
		glVertexPointerd(RightTriTile.verts)
		
		def simpleDraw(x, y, angle):
			glPushMatrix()
			glTranslated(x, y, 0.)
			glRotated(angle, 0, 0, 1)
			glScaled(width, height, 1.)
		
			glDrawArrays(GL_TRIANGLES, 0, 3)
		
			glPopMatrix()
		
		if self.state in [ 'flying', 'grabbed' ]:
			glEnable(GL_BLEND)
			if self.state == 'grabbed':
				glColor4d(0, 0, 0, 0.8)
				mouseX, mouseY = self.grid.getMousePos()
				simpleDraw(
					mouseX + self.mouseOffset[0], mouseY + self.mouseOffset[1],
					180*self.grabbedIdx)
			else:
				glColor4d(0, 0, 0, 0.8/self.motionBlurSteps)
				deltaX, deltaY = self.nextPose.pos - self.pose.pos
				deltaAngle = self.nextPose.angle - self.pose.angle
				for n in range(self.motionBlurSteps):
					simpleDraw(
						self.pose.pos[0] + n*deltaX/self.motionBlurSteps,
						self.pose.pos[1] + n*deltaY/self.motionBlurSteps,
						self.pose.angle + n*deltaAngle/self.motionBlurSteps)
			glDisable(GL_BLEND)
			glColor4d(0, 0, 0, 1)
		else:
			simpleDraw(
				(self.loc[0]+0.5)*width, (self.loc[1]+0.5)*height,
				180*self.loc[2])
		
		glMatrixMode(GL_TEXTURE)
		glPopMatrix()
		glMatrixMode(GL_MODELVIEW)
	
	def drawHighlight(self, aspect):
		width = float(self.grid.vidSize[0])/self.grid.cols
		height = float(self.grid.vidSize[1])/self.grid.rows
		col, row, dstIdx = self.grid.tiles.inv[self]
		dstX = (col+0.5)*width
		dstY = (row+0.5)*height
		glPushMatrix()
		glTranslated(dstX, dstY, 0.)
		glRotated(180*dstIdx, 0, 0, 1)
		glScaled(width, height, 1.)
		glMatrixMode(GL_TEXTURE)
		glPushMatrix()
		glLoadIdentity()
		glScaled(0.5, 1., 1.)
		glTranslated(0.5, 0., 0.)
		
		glEnable(GL_BLEND)
		glBindTexture(GL_TEXTURE_2D, RightTriTile.hlTex)
		glTexCoordPointerd(RightTriTile.hlSideTexCoords)
		glVertexPointerd(RightTriTile.hlSideVerts)
		glDrawArrays(GL_QUADS, 0, len(RightTriTile.hlSideVerts))
		for i in range(len(RightTriTile.hlCornerVerts)):
			glTexCoordPointerd(RightTriTile.hlCornerTexCoords[i])
			glVertexPointerd(RightTriTile.hlCornerVerts[i])
			glDrawArrays(GL_TRIANGLE_FAN, 0, len(RightTriTile.hlCornerVerts[i]))
		glDisable(GL_BLEND)
		
		glPopMatrix()
		glMatrixMode(GL_MODELVIEW)
		glPopMatrix()

class TimeDisplay(Actor):
	def __init__(self, grid, time):
		Actor.__init__(self, grid)
		timeStr = "%d:%02d" % (int(time/60), int(time%60))
		surface = cairo.ImageSurface(cairo.FORMAT_A8, winSize[0], winSize[1])
		cairoCtx = cairo.Context(surface)
		pangoCtx = pangocairo.CairoContext(cairoCtx)
		layout = pangoCtx.create_layout()
		layout.set_markup("""\
<span foreground="yellow"><span size="large">Congratulations!</span>
Your time is
<span size="72000">%s</span></span>""" % timeStr)
		layout.set_alignment(pango.ALIGN_CENTER)
		pangoCtx.show_layout(layout)
		self.size = layout.get_pixel_size()
		arrData = np.frombuffer(surface.get_data(), np.uint8)
		arrData = arrData.reshape((winSize[1],winSize[0]))
		color = np.array([255, 255, 0, 255], np.uint8)
		self.pixelData = np.tile(color, (self.size[1], self.size[0], 1))
		self.pixelData[:,:,3] = arrData[:self.size[1], :self.size[0]]
		del surface
		
		self.pos = [
			(self.grid.vidSize[0] - self.size[0])/2.,
			(self.grid.vidSize[1] - self.size[1])/2.]
	
		self.grid.drawOverlays.addHandler(self.__class__.draw, self)
		self.time = 0.
		self.state = 'sitting'
	
	def update(self, deltaT):
		if self.state == 'sitting':
			if self.time < 3.:
				self.time += deltaT
			else:
				self.state = 'falling'
				self.time = 0.
		elif self.state == 'falling':
			if self.pos[1]+self.size[1] > -self.grid.vidOrigin[1]:
				self.time += deltaT
				self.pos[1] += -1500 * self.time * deltaT
			else:
				self.die()
	
	def draw(self):
		glDisable(GL_TEXTURE_2D)
		glEnable(GL_BLEND)
		glColor4d(0., 0., 0., 0.5)
		glRectd(
			self.pos[0], self.pos[1],
			self.pos[0] + self.size[0], self.pos[1] + self.size[1])
		glRasterPos2d(self.pos[0], self.pos[1]+self.size[1])
		oldZoomX = glGetDouble(GL_ZOOM_X)
		oldZoomY = glGetDouble(GL_ZOOM_Y)
		glPixelZoom(1., -1.)
		glDrawPixels(
			self.size[0], self.size[1], GL_RGBA, GL_UNSIGNED_BYTE,
			self.pixelData)
		glPixelZoom(oldZoomX, oldZoomY)
		glDisable(GL_BLEND)
		glEnable(GL_TEXTURE_2D)

if __name__ == '__main__':
	pygame.display.init()
	pygame.display.set_mode(winSize, pygame.OPENGL|pygame.DOUBLEBUF)
	pygame.display.set_caption("Escher's Mirror", "Escher's Mirror")
	glPixelStorei(GL_UNPACK_ALIGNMENT, 1)
	glEnable(GL_TEXTURE_2D)
	glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE)
	glEnableClientState(GL_TEXTURE_COORD_ARRAY)
	glEnableClientState(GL_VERTEX_ARRAY)
	glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA)
	glClearColor(0.0, 0.0, 0.0, 1.0)
	glMatrixMode(GL_MODELVIEW)
	glLoadIdentity()
	
	grid = RightTriGrid(2, 3)
	grid.run()

# vim: set ts=4 sts=4 sw=4 noet :
